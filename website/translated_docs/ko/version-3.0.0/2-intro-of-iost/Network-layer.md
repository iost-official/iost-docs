---
id: Network-layer
title: 네트워크 레이어
sidebar_label: 네트워크 레이어
---

P2P(Peer-to-Peer) 네트워크는 탈중앙화된 구조로, 피어간에 태스크와 워크로드를 분산시키는 네트워크를 말합니다. P2P 네트워크에서는, 연결된 컴퓨터들은 모두 동일하게 취급되며, 각 노드(컴퓨터)는 리소스 제공자이면서 리소스 소비자가 될 수 있습니다. 여기서 말하는 리소스는 단순 리소스 뿐만 아니라 서비스, 컨텐츠 또한 포함되는 개념입니다. 기존의 전통적인 클라이언트-서버 네트워크 모델과는 달리, P2P 네트워크는 '탈중앙화', '확장성', '공격 저항성', '은밀성(private)'이라는 장점을 가집니다. 이러한 이점들은 블록체인 시스템을 작동시키고 자유롭고 자율적인 분산적인 블록체인의 기반이 되는 요소들로서 작용합니다.

## IOST 네트워크 레이어 구성

IOST는 노드 간에 탐색속도를 빠르게 하고, IOST 네트워크에서 발생하는 트랜잭션과 블록의 전파를 신속하게 하여 완전히 탈중앙화된 네트워크 토폴로지를 구성하는데에 초점을 두고 있습니다. 이와 동시에, 네트워크에 발생할 수 있는 중복을 제한하고, 노드 간에 안전한 데이터 전송을 목표로 하고 있습니다. 이러한 목표 달성을 위해서 연구와 테스트를 해본 결과, [libp2p](https://github.com/libp2p/go-libp2p) 라는 강력한 라이브러리를 IOST의 네트워크 레이어로 채택하기로 하였습니다.

### 노드 탐색과 연결

가장 기초가 되는 프로토콜은 TCP/IP 입니다. 도청(eavesdropping)과 원치 않는 데이터 조작을 막기 위해, TCP의 TLS 레이어를 통해 데이터를 보호합니다. 더불어, 각 TCP 연결을 더 잘 활용하기 위해서 스트림 멀티플렉싱을 이용해서 데이터를 주고받으며, 노드 간에 여러 스트림을 동적으로 설정하여 대역폭을 극대화합니다.

IOST 네트워크를 구성하는 각 노드들은 [Kademlia](https://en.wikipedia.org/wiki/Kademlia) 알고리즘을 사용하여 각 노드만의 게이트웨이 테이블을 구성합니다. Kademlia 알고리즘은 노드들의 ID값에 XOR 연산을 하여 노드 간의 거리를 계산 하는데, 이 때 노드들은 다른 노드들과의 거리를 기준으로 버킷에 배치됩니다. 이를 통해서, 어느 한 노드를 쿼리 할 때에는, 해당 버킷 내에서 가장 가까운 노드만 찾으면 됩니다. 따라서 일정한 수의 쿼리만으로 노드에 대한 정보를 찾을 수 있습니다. 이러한 방식으로 Kademlia 알고리즘은 속도가 빠르고, 여러 분야에서 쓰일 수 있다는 점에서 장점을 가지는 알고리즘입니다.

### 데이터 전송
데이터 전송의 대역폭을 줄이고 속도를 올리기 위해서 IOST는 구조화된 데이터(structured data)를 프로토콜 버퍼를 이용해 직렬화 하고 Snappy 알고리즘을 이용하여 압축합니다. 실제로 이렇게 프로토콜 버퍼 + Snappy 알고리즘을 이용 해본 결과, 데이터의 크기를 80% 이상 줄일 수 있었습니다.

또한, 브로드캐스팅에 대해서 말해보자면, 브로드캐스팅은 일반적으로 데이터 중복 전송을 초래 할 수 있습니다. 따라서 대역폭과 처리 능력을 낭비하게 되는데, 많은 프로젝트들에서는 이러한 데이터 중복 전송 문제를 \*네트워크 홉("hops")을 제한하는 것으로 해결하려 하고 있습니다. 하지만 이러한 방법은 종종 데이터가 전체 네트워크에 도달하는 것에 대해서 보장하지 못합니다. 특히 방대한 네트워크에서는 더욱 그렇습니다. 예를 들어, EOS가 이 문제를 해결하는 방식에 대해서 말해보자면, 네트워크 레이어는 각 노드의 이웃(neighbor)의 트랜잭션과 블록에 대해서 로그를 남기고, 이를 통해 특정 노드에 데이터를 보낼지 여부를 결정합니다. 이러한 설계는 물론 데이터 중복 전송을 어느정도 줄일 순 있지만, 많은 로그에 대해서 기록해야 한다는 점에서 스토리지에 부하를 주고, 그다지 매력적인 방법이라고 볼 수 없습니다.

\*홉: 홉은 컴퓨터 네트워크에서 출발지와 목적지 사이에 위치한 경로의 한 부분을 말합니다.

IOST는 이러한 데이터 중복 전송 문제를 해결하는데에 있어서 필터 알고리즘을 채택했습니다. 필터 알고리즘은 중복된 정보를 제거하는데 사용되는데, 이러한 필터 알고리즘에는 [Bloom Filter](https://en.wikipedia.org/wiki/Bloom_filter), [Cuckoo Filter](https://brilliant.org/wiki/cuckoo-filter/) 등등이 있습니다. 많은 알고리즘들에 대해서 비교해본 결과 IOST는 블룸필터를 필터 알고리즘으로 채택했습니다. 이를 통해 단 1.7메가의 스토리지를 통해서 0.1%의 오차범위 내에서 수백만의 데이터 패킷의 중복을 제거할 수 있었습니다. 이 뿐만 아니라, 데이터 중복 전송을 더욱 줄이기 위해서, IOST는 블록과 사이즈가 큰 트랜잭션에 대한 전송에 있어서 데이터 자체를 먼저 보내는 것이 아니라 이들의 해시를 우선적으로 전송하는 특별한 정책을 사용합니다. 이를 통해서 각 블록과 큰 트랜잭션을 전송받으려는 노드들은 해시를 비교하여 자신이 이미 갖고 있는 데이터라면 전송받지 않고, 없는 데이터라면 전송을 받아서 데이터 중복을 줄입니다.

### LAN penetration
IOST는 [UPnP](https://en.wikipedia.org/wiki/Universal_Plug_and_Play) LAN penetration에 프로토콜을 사용합니다. UPnP는 [UDP Hole Punching](https://en.wikipedia.org/wiki/UDP_hole_punching) 이나 [STUN](https://en.wikipedia.org/wiki/STUN)의 방식과는 다릅니다. UPnP는 서버를 띄워서 따로 포트를 노출하지 않아도 되는 방식이라, 따로 클라우드 서버를 사용할 필요없이 여러분의 가정에서 쓰는 컴퓨터 만으로 IOST 네트워크에 접속하여 다른 노드들과의 커뮤니케이션이 가능합니다.

## 이스터 에그
IOST의 go-iost 코드 리포지토리의 P2P 네트워크 패키지에 보면, `/example` 이라고 하는 폴더가 존재합니다. 여기에 앞서 소개한 네트워크 패키지를 이용한 간단한 메시지 앱을 만들어 두었는데요, 이 폴더에서 `$ go build`를 실행해보시면 바이너리 파일이 생성되는데, 이를 통해서 IOST 네트워크에 있는 다른 사람들과 채팅을 즐길 수 있습니다! :)

https://github.com/iost-official/go-iost/tree/master/p2p/example  
